---
import { toChildArray } from 'preact';
import Picture from './Picture.astro';
import './carousel.scss';

interface Props { 
  id: number;
  media: { png: string; webp?: string | undefined; }[];
  className: string; 
}
const { id, media, className } = Astro.props;
---
<div class={"carousel " + className} data-id={id} data-state="running">  
    {
      media.map( ({ png, webp }, index, arr) => <div 
      class="carousel__item carousel__item--hide carousel__item--display-none" data-id={id} >
          <Picture slot="mobile" png={png} webp={webp || png} alt={png} />  
        </div> )
    }
</div>

<script>

let intervals = new Map<string, NodeJS.Timer>();
const wait = (delay: number) => new Promise((resolve) => setTimeout(resolve, delay));

interface ImageReference { id: string };
// callback for animating flashcards
const flashcards = (id: string): [number, (reference: ImageReference) => Promise<void>] => {
  const items = document.querySelectorAll(`.carousel__item[data-id="${id}"]`);
  const count = items.length;
  const hideClassName = 'carousel__item--hide';
  const flashFunction = async (reference: ImageReference) => {        
        for(let item of items) {
          const { classList } = item as HTMLImageElement;
          if(classList.contains(hideClassName) && intervals.has(reference.id)) {
              classList.remove(hideClassName);
              let count = 0;
              for(let i=0; i<27; i+=1){
                // will lead to the item being hidden faster when cancelled
                if (intervals.has(reference.id)) {
                  await wait(100);
                }
                count += 1;
              }
              classList.add(hideClassName);
              // align with the duration of the animation
              await wait(200);
          }
        }
      }
  return [count, flashFunction];
}

// Use intersection observer to run animation each time when
// element comes into viewport
const options = {
  root: null, // defaults to viewport
  rootMargin: '-100px 0px -100px 0px',
  // threshold: 1.0,
}
const callback = (entries:  IntersectionObserverEntry[]) => {  
  entries.forEach((entry) => {
    const { target, isIntersecting } = entry;
    const id: string = target?.getAttribute('data-id') || '';
    const [count, flashFunction ] = flashcards(id);
    const reference: ImageReference = { id };
    if (isIntersecting) {
      const interval = setInterval(() => flashFunction(reference), 3150 * count);      
      intervals.set(id, interval);      
      flashFunction(reference);
    } else {        
      clearInterval(intervals.get(id));   
      intervals.delete(id);
    }
  });
};    

let observer = new IntersectionObserver(callback, options);  

// after loosing visiblity and re-entering animations start to overlap
// they one loop needs to be terminated to avoid that
// as far as I was able to debug this issue, it is not due to Interval or IntersectionObserver events;
// rather something to do with applying css class changes and browser repainting
document.addEventListener("visibilitychange", () => {
  if(document.visibilityState === "hidden") {
    const copy = new Map(intervals.entries());
    intervals.clear();
    setTimeout(() => {intervals = copy;}, 200);
  }
})
    
// adds behavior for carousels
const carousels = document.querySelectorAll('.carousel');      
 
carousels.forEach((carousel) => {
  const id: string = carousel?.getAttribute('data-id') || '';
  if (carousel) observer.observe(carousel);
})  
</script>